function t(t){if("string"!=typeof t&&"symbol"!=typeof t)throw new TypeError(" EVENTNAME expected: string | symbol;but invalid :"+t)}function e(t){if("function"!=typeof t)throw new TypeError(" EVENTLISTENER expected: (event?: any) => void;but invalid:"+t)}const n="EventEmitterTarget";function o(){return{}.toString.call({[Symbol.toStringTag]:n})}export default function i(){const r=function(){const i=new Map,r=new WeakMap;function s(t){let e=i.get(t);return e||(e=new Set,i.set(t,e)),e}function c(e){t(e),i.has(e)&&s(e).clear()}function u(e,n){t(e),i.has(e)&&s(e).forEach(t=>{Promise.resolve().then(()=>{t(n)})})}function f(n,o){t(n),e(o),s(n).add(o)}function a(t,e){s(t).delete(e)}function l(n,o){t(n),e(o),a(n,o),function(t,e){const n=s(t);let o=r.get(e);o&&n.delete(o)}(n,o)}function m(){return[...i].map(([t,e])=>[t,[...e]])[Symbol.iterator]()}return{[Symbol.toPrimitive]:o,[Symbol.toStringTag]:n,[Symbol.iterator]:m,entries:m,listenerCount:function(e){return t(e),i.has(e)?s(e).size:0},clear:c,removeAllListeners:c,on:f,addListener:f,off:l,removeListener:l,once:function(n,o){t(n),e(o);let i=!1,s=r.get(o);if(!s){const t=e=>{a(n,t),a(n,o),i||(i=!0,o(e))};s=t,r.set(o,s)}a(n,o),f(n,s)},emit:u,dispatch:u,eventNames:function(){return[...i.keys()]},listeners:function(e){return t(e),i.has(e)?[...s(e)]:[]}}}();return this&&this instanceof i?(Object.assign(this,r),this):Reflect.construct(i,[])}
//# sourceMappingURL=index.js.map
