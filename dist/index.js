function t(t){if("string"!=typeof t&&"symbol"!=typeof t)throw new TypeError(" EVENTNAME expected: string | symbol;but invalid :"+t)}function e(t){if("function"!=typeof t)throw new TypeError(" EVENTLISTENER expected: (event?: any) => void;but invalid:"+t)}const n="EventEmitterTarget";function i(){return{}.toString.call({[Symbol.toStringTag]:n})}export default function o(){const r=function(){const o=new Map,r=new WeakMap;function c(t){let e=o.get(t);return e||(e=new Set,o.set(t,e)),e}function s(e){if(t(e),o.has(e)){c(e).clear()}}function f(e,n){if(t(e),o.has(e)){c(e).forEach(t=>{Promise.resolve().then(()=>{t(n)})})}}function u(n,i){t(n),e(i),c(n).add(i)}function a(t,e){c(t).delete(e)}function l(n,i){t(n),e(i),a(n,i),function(t,e){const n=c(t);let i=r.get(e);i&&n.delete(i)}(n,i)}return{[Symbol.toPrimitive]:i,[Symbol.toStringTag]:n,[Symbol.iterator]:function(){return[...o].map(([t,e])=>[t,[...e]])[Symbol.iterator]()},listenerCount:function(e){if(t(e),o.has(e)){return c(e).size}return 0},clear:s,removeAllListeners:s,on:u,addListener:u,off:l,removeListener:l,once:function(n,i){t(n),e(i);let o=!1,c=r.get(i);if(!c){const t=e=>{a(n,t),a(n,i),o||(o=!0,i(e))};c=t,r.set(i,c)}a(n,i),u(n,c)},emit:f,dispatch:f,eventNames:function(){return[...o.keys()]},listeners:function(e){if(t(e),o.has(e)){return[...c(e)]}return[]}}}();return this&&this instanceof o?(Object.assign(this,r),this):Reflect.construct(o,[])}
//# sourceMappingURL=index.js.map
