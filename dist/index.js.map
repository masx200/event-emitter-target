{"version":3,"file":"index.js","sources":["../src/index.ts"],"sourcesContent":["export type EventEmitterTarget = ReturnType<typeof createEventEmitterTarget>;\r\nexport interface EventEmitterTargetConstructor {\r\n  new (): EventEmitterTarget;\r\n  (this: EventEmitterTarget | undefined): EventEmitterTarget;\r\n}\r\nconst EventEmitterTargetClass: EventEmitterTargetConstructor = function EventEmitterTargetClass(\r\n  this: EventEmitterTarget | undefined\r\n): EventEmitterTarget {\r\n  const eventemittertarget = createEventEmitterTarget();\r\n  if (this && this instanceof EventEmitterTargetClass) {\r\n    Object.assign(this, eventemittertarget);\r\n    return this as EventEmitterTarget;\r\n  } else {\r\n    return Reflect.construct(EventEmitterTargetClass, []) as EventEmitterTarget;\r\n  }\r\n} as EventEmitterTargetConstructor;\r\nexport type EVENTNAME = string | symbol;\r\nexport type EVENTLISTENER = (event?: any) => void;\r\nexport default EventEmitterTargetClass;\r\n\r\nfunction createEventEmitterTarget() {\r\n  const 监听器回调映射 = new Map<EVENTNAME, Set<EVENTLISTENER>>();\r\n  const 源回调到一次包装 = new WeakMap<EVENTLISTENER, EVENTLISTENER>();\r\n  function 获取监听器集合(name: EVENTNAME): Set<EVENTLISTENER> {\r\n    let 监听器集合: Set<EVENTLISTENER> | undefined = 监听器回调映射.get(name);\r\n    if (!监听器集合) {\r\n      监听器集合 = new Set();\r\n      监听器回调映射.set(name, 监听器集合);\r\n    }\r\n    return 监听器集合;\r\n  }\r\n\r\n  function clear(name: EVENTNAME) {\r\n    assertEVENTNAME(name);\r\n    if (监听器回调映射.has(name)) {\r\n      const 监听器集合 = 获取监听器集合(name);\r\n      监听器集合.clear();\r\n    }\r\n  }\r\n  function emit(name: EVENTNAME, event?: any) {\r\n    assertEVENTNAME(name);\r\n    if (监听器回调映射.has(name)) {\r\n      const 监听器集合 = 获取监听器集合(name);\r\n      监听器集合.forEach(listener => {\r\n        Promise.resolve().then(() => {\r\n          listener(event);\r\n        });\r\n      });\r\n    }\r\n  }\r\n  function once(name: EVENTNAME, callback: EVENTLISTENER) {\r\n    assertEVENTNAME(name);\r\n    assertEVENTLISTENER(callback);\r\n    let fired = false;\r\n    let wrapped = 源回调到一次包装.get(callback);\r\n    if (!wrapped) {\r\n      const 一次包装 = (event?: any) => {\r\n        offraw(name, 一次包装);\r\n        offraw(name, callback);\r\n        if (!fired) {\r\n          fired = true;\r\n          callback(event);\r\n        }\r\n      };\r\n      wrapped = 一次包装;\r\n      源回调到一次包装.set(callback, wrapped);\r\n    }\r\n    offraw(name, callback);\r\n    on(name, wrapped);\r\n  }\r\n  function on(name: EVENTNAME, callback: EVENTLISTENER) {\r\n    assertEVENTNAME(name);\r\n    assertEVENTLISTENER(callback);\r\n    const 监听器集合 = 获取监听器集合(name);\r\n    监听器集合.add(callback);\r\n  }\r\n  function offraw(name: EVENTNAME, callback: EVENTLISTENER) {\r\n    const 监听器集合 = 获取监听器集合(name);\r\n    监听器集合.delete(callback);\r\n  }\r\n  function offwrap(name: EVENTNAME, callback: EVENTLISTENER) {\r\n    const 监听器集合 = 获取监听器集合(name);\r\n    let 一次包装 = 源回调到一次包装.get(callback);\r\n    if (一次包装) {\r\n      监听器集合.delete(一次包装);\r\n    }\r\n  }\r\n  function off(name: EVENTNAME, callback: EVENTLISTENER) {\r\n    assertEVENTNAME(name);\r\n    assertEVENTLISTENER(callback);\r\n\r\n    offraw(name, callback);\r\n    offwrap(name, callback);\r\n  }\r\n\r\n  function eventNames(): EVENTNAME[] {\r\n    return [...监听器回调映射.keys()];\r\n  }\r\n  function listeners(name: EVENTNAME): EVENTLISTENER[] {\r\n    assertEVENTNAME(name);\r\n    if (监听器回调映射.has(name)) {\r\n      const 监听器集合 = 获取监听器集合(name);\r\n      return [...监听器集合];\r\n    } else {\r\n      return [];\r\n    }\r\n  }\r\n  function listenerCount(name: EVENTNAME): number {\r\n    assertEVENTNAME(name);\r\n    if (监听器回调映射.has(name)) {\r\n      const 监听器集合 = 获取监听器集合(name);\r\n      return 监听器集合.size;\r\n    } else {\r\n      return 0;\r\n    }\r\n  }\r\n\r\n  function iterator(): IterableIterator<[EVENTNAME, EVENTLISTENER[]]> {\r\n    let resultarr: Array<[EVENTNAME, EVENTLISTENER[]]> = [\r\n      ...监听器回调映射\r\n    ].map(([key, value]) => {\r\n      return [key, [...value]] as [EVENTNAME, EVENTLISTENER[]];\r\n    });\r\n\r\n    return resultarr[Symbol.iterator]();\r\n  }\r\n  const eventtarget = {\r\n    [Symbol.toPrimitive]: toprimitive,\r\n\r\n    [Symbol.toStringTag]: toStringTag,\r\n    [Symbol.iterator]: iterator,\r\n    listenerCount,\r\n    clear,\r\n    removeAllListeners: clear,\r\n    on,\r\n    addListener: on,\r\n    off,\r\n    removeListener: off,\r\n    once,\r\n    emit,\r\n    dispatch: emit,\r\n    eventNames,\r\n    listeners\r\n  };\r\n  return eventtarget;\r\n}\r\nfunction assertEVENTNAME(name: any): asserts name is EVENTNAME {\r\n  if (\"string\" !== typeof name && \"symbol\" !== typeof name) {\r\n    throw new TypeError(\r\n      \" EVENTNAME expected: string | symbol;but invalid :\" + name\r\n    );\r\n  }\r\n}\r\n\r\nfunction assertEVENTLISTENER(callback: any): asserts callback is EVENTLISTENER {\r\n  if (\"function\" !== typeof callback) {\r\n    throw new TypeError(\r\n      \" EVENTLISTENER expected: (event?: any) => void;but invalid:\" + callback\r\n    );\r\n  }\r\n}\r\nconst toStringTag = \"EventEmitterTarget\";\r\nfunction toprimitive(): string {\r\n  return {}.toString.call({ [Symbol.toStringTag]: toStringTag });\r\n}\r\n"],"names":["assertEVENTNAME","name","TypeError","assertEVENTLISTENER","callback","toStringTag","toprimitive","toString","call","Symbol","EventEmitterTargetClass","eventemittertarget","监听器回调映射","Map","源回调到一次包装","WeakMap","获取监听器集合","监听器集合","get","Set","set","clear","has","emit","event","forEach","listener","Promise","resolve","then","on","add","offraw","delete","off","一次包装","offwrap","toPrimitive","iterator","map","key","value","listenerCount","size","removeAllListeners","addListener","removeListener","once","fired","wrapped","dispatch","eventNames","keys","listeners","createEventEmitterTarget","this","Object","assign","Reflect","construct"],"mappings":"AAkJA,SAASA,EAAgBC,MACnB,iBAAoBA,GAAQ,iBAAoBA,QAC5C,IAAIC,UACR,qDAAuDD,GAK7D,SAASE,EAAoBC,MACvB,mBAAsBA,QAClB,IAAIF,UACR,8DAAgEE,GAItE,MAAMC,EAAc,qBACpB,SAASC,UACA,GAAGC,SAASC,KAAK,EAAGC,OAAOJ,aAAcA,mBA9Ja,SAASK,UAGhEC,EAYR,iBACQC,EAAU,IAAIC,IACdC,EAAW,IAAIC,iBACZC,EAAQf,OACXgB,EAAwCL,EAAQM,IAAIjB,UACnDgB,IACHA,EAAQ,IAAIE,IACZP,EAAQQ,IAAInB,EAAMgB,IAEbA,WAGAI,EAAMpB,MACbD,EAAgBC,GACZW,EAAQU,IAAIrB,GAAO,CACPe,EAAQf,GAChBoB,kBAGDE,EAAKtB,EAAiBuB,MAC7BxB,EAAgBC,GACZW,EAAQU,IAAIrB,GAAO,CACPe,EAAQf,GAChBwB,QAAQC,IACZC,QAAQC,UAAUC,KAAK,KACrBH,EAASF,iBAyBRM,EAAG7B,EAAiBG,GAC3BJ,EAAgBC,GAChBE,EAAoBC,GACNY,EAAQf,GAChB8B,IAAI3B,YAEH4B,EAAO/B,EAAiBG,GACjBY,EAAQf,GAChBgC,OAAO7B,YASN8B,EAAIjC,EAAiBG,GAC5BJ,EAAgBC,GAChBE,EAAoBC,GAEpB4B,EAAO/B,EAAMG,YAXEH,EAAiBG,SAC1Ba,EAAQD,EAAQf,OAClBkC,EAAOrB,EAASI,IAAId,GACpB+B,GACFlB,EAAMgB,OAAOE,GAQfC,CAAQnC,EAAMG,SAkCI,EACjBK,OAAO4B,aAAc/B,GAErBG,OAAOJ,aAAcA,GACrBI,OAAO6B,2BAZ6C,IAChD1B,GACH2B,IAAI,EAAEC,EAAKC,KACJ,CAACD,EAAK,IAAIC,KAGFhC,OAAO6B,aAOxBI,uBAxBqBzC,MACrBD,EAAgBC,GACZW,EAAQU,IAAIrB,GAAO,QACPe,EAAQf,GACT0C,YAEN,GAmBTtB,MAAAA,EACAuB,mBAAoBvB,EACpBS,GAAAA,EACAe,YAAaf,EACbI,IAAAA,EACAY,eAAgBZ,EAChBa,cAxFY9C,EAAiBG,GAC7BJ,EAAgBC,GAChBE,EAAoBC,OAChB4C,GAAQ,EACRC,EAAUnC,EAASI,IAAId,OACtB6C,EAAS,OACNd,EAAQX,IACZQ,EAAO/B,EAAMkC,GACbH,EAAO/B,EAAMG,GACR4C,IACHA,GAAQ,EACR5C,EAASoB,KAGbyB,EAAUd,EACVrB,EAASM,IAAIhB,EAAU6C,GAEzBjB,EAAO/B,EAAMG,GACb0B,EAAG7B,EAAMgD,IAuET1B,KAAAA,EACA2B,SAAU3B,EACV4B,4BA7CO,IAAIvC,EAAQwC,SA8CnBC,mBA5CiBpD,MACjBD,EAAgBC,GACZW,EAAQU,IAAIrB,GAAO,OAEd,IADOe,EAAQf,UAGf,KAhGgBqD,UACvBC,MAAQA,gBAAgB7C,GAC1B8C,OAAOC,OAAOF,KAAM5C,GACb4C,MAEAG,QAAQC,UAAUjD,EAAyB"}