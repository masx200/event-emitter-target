{"version":3,"file":"index.js","sources":["../src/index.ts"],"sourcesContent":["export type EventEmitterTarget = ReturnType<typeof createEventEmitterTarget>;\r\nexport interface EventEmitterTargetConstructor {\r\n  new (): EventEmitterTarget;\r\n  (this: EventEmitterTarget | undefined): EventEmitterTarget;\r\n}\r\nconst EventEmitterTargetClass: EventEmitterTargetConstructor = function EventEmitterTargetClass(\r\n  this: EventEmitterTarget | undefined\r\n): EventEmitterTarget {\r\n  const eventemittertarget = createEventEmitterTarget();\r\n  if (this && this instanceof EventEmitterTargetClass) {\r\n    Object.assign(this, eventemittertarget);\r\n    return this as EventEmitterTarget;\r\n  } else {\r\n    return Reflect.construct(EventEmitterTargetClass, []) as EventEmitterTarget;\r\n  }\r\n} as EventEmitterTargetConstructor;\r\nexport type EVENTNAME = string | symbol;\r\nexport type EVENTLISTENER = (event?: any) => void;\r\nexport default EventEmitterTargetClass;\r\n\r\nfunction createEventEmitterTarget() {\r\n  const 监听器回调映射 = new Map<EVENTNAME, Set<EVENTLISTENER>>();\r\n  const 源回调到一次包装 = new WeakMap<EVENTLISTENER, EVENTLISTENER>();\r\n  function 获取监听器集合(name: EVENTNAME): Set<EVENTLISTENER> {\r\n    let 监听器集合: Set<EVENTLISTENER> | undefined = 监听器回调映射.get(name);\r\n    if (!监听器集合) {\r\n      监听器集合 = new Set();\r\n      监听器回调映射.set(name, 监听器集合);\r\n    }\r\n    return 监听器集合;\r\n  }\r\n\r\n  function clear(name: EVENTNAME) {\r\n    assertEVENTNAME(name);\r\n    if (监听器回调映射.has(name)) {\r\n      const 监听器集合 = 获取监听器集合(name);\r\n      监听器集合.clear();\r\n    }\r\n  }\r\n  function emit(name: EVENTNAME, event?: any) {\r\n    assertEVENTNAME(name);\r\n    if (监听器回调映射.has(name)) {\r\n      const 监听器集合 = 获取监听器集合(name);\r\n      监听器集合.forEach(listener => {\r\n        Promise.resolve().then(() => {\r\n          listener(event);\r\n        });\r\n      });\r\n    }\r\n  }\r\n  function once(name: EVENTNAME, callback: EVENTLISTENER) {\r\n    assertEVENTNAME(name);\r\n    assertEVENTLISTENER(callback);\r\n    let fired = false;\r\n    let wrapped = 源回调到一次包装.get(callback);\r\n    if (!wrapped) {\r\n      const 一次包装 = (event?: any) => {\r\n        offraw(name, 一次包装);\r\n        offraw(name, callback);\r\n        if (!fired) {\r\n          fired = true;\r\n          callback(event);\r\n        }\r\n      };\r\n      wrapped = 一次包装;\r\n      源回调到一次包装.set(callback, wrapped);\r\n    }\r\noffraw(name, callback);\r\n    on(name, wrapped);\r\n\r\n    \r\n  }\r\n  function on(name: EVENTNAME, callback: EVENTLISTENER) {\r\n    assertEVENTNAME(name);\r\n    assertEVENTLISTENER(callback);\r\n    const 监听器集合 = 获取监听器集合(name);\r\n    监听器集合.add(callback);\r\n  }\r\n  function offraw(name: EVENTNAME, callback: EVENTLISTENER){\r\n  \tconst 监听器集合 = 获取监听器集合(name);\r\n    监听器集合.delete(callback);\r\n  \r\n}\r\nfunction offwrap(name: EVENTNAME, callback: EVENTLISTENER){\r\n  \tconst 监听器集合 = 获取监听器集合(name);\r\n let 一次包装 = 源回调到一次包装.get(callback);\r\n    if (一次包装) {\r\n      监听器集合.delete(一次包装);\r\n    }\r\n  \r\n}\r\n  function off(name: EVENTNAME, callback: EVENTLISTENER) {\r\n    assertEVENTNAME(name);\r\n    assertEVENTLISTENER(callback);\r\n\r\n  offraw(name,callback)\r\n  offwrap(name,callback)\r\n  }\r\n\r\n  function eventNames(): EVENTNAME[] {\r\n    return [...监听器回调映射.keys()];\r\n  }\r\n  function listeners(name: EVENTNAME): EVENTLISTENER[] {\r\n    assertEVENTNAME(name);\r\n    if (监听器回调映射.has(name)) {\r\n      const 监听器集合 = 获取监听器集合(name);\r\n      return [...监听器集合];\r\n    } else {\r\n      return [];\r\n    }\r\n  }\r\n  function listenerCount(name: EVENTNAME): number {\r\n    assertEVENTNAME(name);\r\n    if (监听器回调映射.has(name)) {\r\n      const 监听器集合 = 获取监听器集合(name);\r\n      return 监听器集合.size;\r\n    } else {\r\n      return 0;\r\n    }\r\n  }\r\n\r\n  function iterator(): IterableIterator<[EVENTNAME, EVENTLISTENER[]]> {\r\n    let resultarr:Array<[EVENTNAME, EVENTLISTENER[]]> = [...监听器回调映射].map(([key, value]) => {\r\n      return [key, [...value]]as [EVENTNAME, EVENTLISTENER[]] ;\r\n    });\r\n    \r\n    return resultarr [Symbol.iterator]()\r\n  }\r\n  const eventtarget = {\r\n    [Symbol.toPrimitive]: toprimitive,\r\n\r\n    [Symbol.toStringTag]: toStringTag,\r\n    [Symbol.iterator]: iterator,\r\n    listenerCount,\r\n    clear,\r\n    removeAllListeners: clear,\r\n    on,\r\n    addListener: on,\r\n    off,\r\n    removeListener: off,\r\n    once,\r\n    emit,\r\n    dispatch: emit,\r\n    eventNames,\r\n    listeners\r\n  };\r\n  return eventtarget;\r\n}\r\nfunction assertEVENTNAME(name: any): asserts name is EVENTNAME {\r\n  if (\"string\" !== typeof name && \"symbol\" !== typeof name) {\r\n    throw new TypeError(\r\n      \" EVENTNAME expected: string | symbol;but invalid :\" + name\r\n    );\r\n  }\r\n}\r\n\r\nfunction assertEVENTLISTENER(callback: any): asserts callback is EVENTLISTENER {\r\n  if (\"function\" !== typeof callback) {\r\n    throw new TypeError(\r\n      \" EVENTLISTENER expected: (event?: any) => void;but invalid:\" + callback\r\n    );\r\n  }\r\n}\r\nconst toStringTag = \"EventEmitterTarget\";\r\nfunction toprimitive(): string {\r\n  return {}.toString.call({ [Symbol.toStringTag]: toStringTag });\r\n}\r\n"],"names":["assertEVENTNAME","name","TypeError","assertEVENTLISTENER","callback","toStringTag","toprimitive","toString","call","[object Object]","Symbol","EventEmitterTargetClass","eventemittertarget","监听器回调映射","Map","源回调到一次包装","WeakMap","获取监听器集合","监听器集合","get","Set","set","clear","has","emit","event","forEach","listener","Promise","resolve","then","on","add","offraw","delete","off","一次包装","offwrap","toPrimitive","iterator","map","key","value","listenerCount","size","removeAllListeners","addListener","removeListener","once","fired","wrapped","dispatch","eventNames","keys","listeners","createEventEmitterTarget","this","Object","assign","Reflect","construct"],"mappings":"AAoJA,SAASA,EAAgBC,GACvB,GAAI,iBAAoBA,GAAQ,iBAAoBA,EAClD,MAAM,IAAIC,UACR,qDAAuDD,GAK7D,SAASE,EAAoBC,GAC3B,GAAI,mBAAsBA,EACxB,MAAM,IAAIF,UACR,8DAAgEE,GAItE,MAAMC,EAAc,qBACpB,SAASC,IACP,MAAO,GAAGC,SAASC,KAAK,CAAEC,CAACC,OAAOL,aAAcA,mBAhKa,SAASM,IAGtE,MAAMC,EAYR,WACE,MAAMC,EAAU,IAAIC,IACdC,EAAW,IAAIC,QACrB,SAASC,EAAQhB,GACf,IAAIiB,EAAwCL,EAAQM,IAAIlB,GAKxD,OAJKiB,IACHA,EAAQ,IAAIE,IACZP,EAAQQ,IAAIpB,EAAMiB,IAEbA,EAGT,SAASI,EAAMrB,GAEb,GADAD,EAAgBC,GACZY,EAAQU,IAAItB,GAAO,CACPgB,EAAQhB,GAChBqB,SAGV,SAASE,EAAKvB,EAAiBwB,GAE7B,GADAzB,EAAgBC,GACZY,EAAQU,IAAItB,GAAO,CACPgB,EAAQhB,GAChByB,QAAQC,IACZC,QAAQC,UAAUC,KAAK,KACrBH,EAASF,QA2BjB,SAASM,EAAG9B,EAAiBG,GAC3BJ,EAAgBC,GAChBE,EAAoBC,GACNa,EAAQhB,GAChB+B,IAAI5B,GAEZ,SAAS6B,EAAOhC,EAAiBG,GAClBa,EAAQhB,GACfiC,OAAO9B,GAWf,SAAS+B,EAAIlC,EAAiBG,GAC5BJ,EAAgBC,GAChBE,EAAoBC,GAEtB6B,EAAOhC,EAAKG,GAZd,SAAiBH,EAAiBG,GAC/B,MAAMc,EAAQD,EAAQhB,GACxB,IAAImC,EAAOrB,EAASI,IAAIf,GACjBgC,GACFlB,EAAMgB,OAAOE,GASjBC,CAAQpC,EAAKG,GAkDb,MAlBoB,CAClBK,CAACC,OAAO4B,aAAchC,EAEtBG,CAACC,OAAOL,aAAcA,EACtBI,CAACC,OAAO6B,UAXV,WAKE,MAJoD,IAAI1B,GAAS2B,IAAI,EAAEC,EAAKC,KACnE,CAACD,EAAK,IAAIC,KAGDhC,OAAO6B,aAOzBI,cAtBF,SAAuB1C,GAErB,GADAD,EAAgBC,GACZY,EAAQU,IAAItB,GAAO,CAErB,OADcgB,EAAQhB,GACT2C,KAEb,OAAO,GAiBTtB,MAAAA,EACAuB,mBAAoBvB,EACpBS,GAAAA,EACAe,YAAaf,EACbI,IAAAA,EACAY,eAAgBZ,EAChBa,KA1FF,SAAc/C,EAAiBG,GAC7BJ,EAAgBC,GAChBE,EAAoBC,GACpB,IAAI6C,GAAQ,EACRC,EAAUnC,EAASI,IAAIf,GAC3B,IAAK8C,EAAS,CACZ,MAAMd,EAAQX,IACZQ,EAAOhC,EAAMmC,GACbH,EAAOhC,EAAMG,GACR6C,IACHA,GAAQ,EACR7C,EAASqB,KAGbyB,EAAUd,EACVrB,EAASM,IAAIjB,EAAU8C,GAE7BjB,EAAOhC,EAAMG,GACT2B,EAAG9B,EAAMiD,IAyET1B,KAAAA,EACA2B,SAAU3B,EACV4B,WA5CF,WACE,MAAO,IAAIvC,EAAQwC,SA4CnBC,UA1CF,SAAmBrD,GAEjB,GADAD,EAAgBC,GACZY,EAAQU,IAAItB,GAAO,CAErB,MAAO,IADOgB,EAAQhB,IAGtB,MAAO,KApGgBsD,GAC3B,OAAIC,MAAQA,gBAAgB7C,GAC1B8C,OAAOC,OAAOF,KAAM5C,GACb4C,MAEAG,QAAQC,UAAUjD,EAAyB"}